-- PROYECTO FINAL - BASES DE DATOS II - 2024-1
---- JUAN JOSÉ HERRERA OROZCO
---- SAMUEL ECHEVERRI BLANDÓN

-- CREACIÓN DE TABLESPACES --------------------------------------------------

CREATE TABLESPACE TS_ESTUDIANTES
DATAFILE 'C:\TS\PROYECTO\TS_ESTUDIANTES.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_PROFESORES
DATAFILE 'C:\TS\PROYECTO\TS_PROFESORES.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_GRUPOS
DATAFILE 'C:\TS\PROYECTO\TS_GRUPOS.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_GRUPO_ESTUDIANTE
DATAFILE 'C:\TS\PROYECTO\TS_GRUPO_ESTUDIANTE.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_EXAMENES
DATAFILE 'C:\TS\PROYECTO\TS_EXAMENES.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_GRUPO_EXAMEN
DATAFILE 'C:\TS\PROYECTO\TS_GRUPO_EXAMEN.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_UNIDADES
DATAFILE 'C:\TS\PROYECTO\TS_UNIDADES.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_UNIDAD_GRUPO
DATAFILE 'C:\TS\PROYECTO\TS_UNIDAD_GRUPO.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_PREGUNTAS
DATAFILE 'C:\TS\PROYECTO\TS_PREGUNTAS.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_PREGUNTA_EXAMEN
DATAFILE 'C:\TS\PROYECTO\TS_PREGUNTA_EXAMEN.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_PRIVACIDAD
DATAFILE 'C:\TS\PROYECTO\TS_PRIVACIDAD.DBF'
SIZE 500K AUTOEXTEND OFF;

CREATE TABLESPACE TS_TIPO_PREGUNTA
DATAFILE 'C:\TS\PROYECTO\TS_TIPO_PREGUNTA.DBF'
SIZE 500K AUTOEXTEND OFF;

CREATE TABLESPACE TS_BANCOS
DATAFILE 'C:\TS\PROYECTO\TS_BANCOS.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;

CREATE TABLESPACE TS_TEMAS
DATAFILE 'C:\TS\PROYECTO\TS_TEMAS.DBF'
SIZE 2M AUTOEXTEND ON MAXSIZE 10M;

CREATE TABLESPACE TS_MATERIAS
DATAFILE 'C:\TS\PROYECTO\TS_MATERIAS.DBF'
SIZE 5M AUTOEXTEND ON MAXSIZE 20M;

CREATE TABLESPACE TS_OPCIONES_RESPUESTA
DATAFILE 'C:\TS\PROYECTO\TS_OPCIONES_RESPUESTA.DBF'
SIZE 10M AUTOEXTEND ON MAXSIZE UNLIMITED;


-- CREACIÓN DEL ESQUEMA -------------------------------------------------------

CREATE TABLE ESTUDIANTES 
    ( 
     ID_ESTUDIANTE NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (20 BYTE)  NOT NULL , 
     APELLIDO VARCHAR2 (40 BYTE)  NOT NULL ,  
     EMAIL VARCHAR2 (30 BYTE) NOT NULL UNIQUE,
     CONTRASENA VARCHAR2 (30 BYTE) NOT NULL,
     SEMESTRE NUMBER,
     PRIMARY KEY (ID_ESTUDIANTE)
    ) 
    TABLESPACE TS_ESTUDIANTES
;

CREATE TABLE PROFESORES 
    ( 
     ID_PROFESOR NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (20 BYTE)  NOT NULL , 
     APELLIDO VARCHAR2 (40 BYTE)  NOT NULL ,  
     EMAIL VARCHAR2 (30 BYTE) NOT NULL,
     CONTRASENA VARCHAR2 (30 BYTE) NOT NULL,
     ID_MATERIA NUMBER NOT NULL,
     PRIMARY KEY (ID_PROFESOR)
    ) 
    TABLESPACE TS_PROFESORES
;

CREATE TABLE GRUPOS 
    ( 
     ID_GRUPO NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (20 BYTE)  NOT NULL , 
     SALON_CLASE VARCHAR2 (20 BYTE),
     ID_PROFESOR NUMBER NOT NULL,
     ID_MATERIA NUMBER NOT NULL,
     PRIMARY KEY (ID_GRUPO)
    ) 
    TABLESPACE TS_GRUPOS
;

CREATE TABLE GRUPO_ESTUDIANTE 
    (
     ID_GRUPO NUMBER  NOT NULL ,
     ID_ESTUDIANTE NUMBER  NOT NULL , 
     PRIMARY KEY (ID_GRUPO, ID_ESTUDIANTE)
    )
    TABLESPACE TS_GRUPO_ESTUDIANTE
;

CREATE TABLE EXAMENES 
    ( 
     ID_EXAMEN NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (100 BYTE)  NOT NULL , 
     DESCRIPCION VARCHAR2 (200 BYTE) NOT NULL,
     CODIGO VARCHAR2 (6) NOT NULL,
     TIEMPO INTERVAL DAY(0) TO SECOND(0) NOT NULL,
     CANTIDAD_PREGUNTAS_ALUMNOS NUMBER,
     CANTIDAD_PREGUNTAS_BANCO NUMBER,
     FECHA DATE,
     PORCENTAJE_NOTA_FINAL NUMBER(4,2),
     UMBRAL_APROBACION NUMBER(4,2),
     ID_TEMA NUMBER NOT NULL,
     ID_PROFESOR NUMBER NOT NULL,
     ID_UNIDAD NUMBER,
     PRIMARY KEY (ID_EXAMEN)
    ) 
    TABLESPACE TS_EXAMENES
;

CREATE TABLE GRUPO_EXAMEN
    (
     ID_GRUPO NUMBER  NOT NULL ,
     ID_EXAMEN NUMBER  NOT NULL , 
     PRIMARY KEY (ID_GRUPO, ID_EXAMEN)
    )
    TABLESPACE TS_GRUPO_EXAMEN
;

CREATE TABLE UNIDADES 
    ( 
     ID_UNIDAD NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (200 BYTE)  NOT NULL , 
     PRIMARY KEY (ID_UNIDAD)
    ) 
    TABLESPACE TS_UNIDADES
;

CREATE TABLE UNIDAD_GRUPO
    (
     ID_UNIDAD NUMBER  NOT NULL ,
     ID_GRUPO NUMBER  NOT NULL , 
     PRIMARY KEY (ID_UNIDAD, ID_GRUPO)
    )
    TABLESPACE TS_UNIDAD_GRUPO
;

CREATE TABLE PREGUNTAS 
    ( 
     ID_PREGUNTA NUMBER  NOT NULL , 
     TEXTO_PREGUNTA VARCHAR2 (200 BYTE)  NOT NULL , 
     PORCENTAJE_GENERAL NUMBER(4,2) NOT NULL,
     PORCENTAJE_SUBPREGUNTA NUMBER(4,2),
     TIEMPO INTERVAL DAY(0) TO SECOND(0) NOT NULL,
     ID_PRIVACIDAD NUMBER NOT NULL,
     ID_TIPO_PREGUNTA NUMBER NOT NULL,
     ID_PREGUNTA_GENERAL NUMBER,
     ID_PROFESOR NUMBER NOT NULL,
     ID_BANCO NUMBER,
     PRIMARY KEY (ID_PREGUNTA)
    ) 
    TABLESPACE TS_PREGUNTAS
;


CREATE TABLE PREGUNTA_EXAMEN
    (
     ID_PREGUNTA NUMBER  NOT NULL ,
     ID_EXAMEN NUMBER  NOT NULL , 
     PRIMARY KEY (ID_PREGUNTA, ID_EXAMEN)
    )
    TABLESPACE TS_PREGUNTA_EXAMEN
;

CREATE TABLE PRIVACIDAD 
    ( 
     ID_PRIVACIDAD NUMBER  NOT NULL , 
     TIPO VARCHAR2 (20 BYTE)  NOT NULL , 
     DESCRIPCION VARCHAR2 (200 BYTE) NOT NULL,
     PRIMARY KEY (ID_PRIVACIDAD)
    ) 
    TABLESPACE TS_PRIVACIDAD
;

CREATE TABLE TIPO_PREGUNTA 
    ( 
     ID_TIPO_PREGUNTA NUMBER  NOT NULL , 
     TIPO VARCHAR2 (20 BYTE)  NOT NULL , 
     DESCRIPCION VARCHAR2 (200 BYTE) NOT NULL,
     PRIMARY KEY (ID_TIPO_PREGUNTA)
    ) 
    TABLESPACE TS_TIPO_PREGUNTA
;

CREATE TABLE BANCOS
    ( 
     ID_BANCO NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (100 BYTE)  NOT NULL , 
     ID_TEMA NUMBER NOT NULL,
     PRIMARY KEY (ID_BANCO)
    ) 
    TABLESPACE TS_BANCOS
;


CREATE TABLE TEMAS 
    ( 
     ID_TEMA NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (50 BYTE)  NOT NULL , 
     ID_MATERIA NUMBER,
     ID_BANCO NUMBER,
     PRIMARY KEY (ID_TEMA)
    ) 
    TABLESPACE TS_TEMAS
;

CREATE TABLE MATERIAS 
    ( 
     ID_MATERIA NUMBER  NOT NULL , 
     NOMBRE VARCHAR2 (20 BYTE)  NOT NULL , 
     HORAS_SEMANA NUMBER,
     CREDITOS NUMBER,
     PRIMARY KEY (ID_MATERIA)
    ) 
    TABLESPACE TS_MATERIAS
;

CREATE TABLE OPCIONES_RESPUESTA 
    ( 
     ID_OPCION_RESPUESTA NUMBER  NOT NULL , 
     TEXTO_RESPUESTA VARCHAR2 (200 BYTE)  NOT NULL , 
     CORRECTA NUMBER NOT NULL,
     ID_PREGUNTA NUMBER NOT NULL,
     PRIMARY KEY (ID_OPCION_RESPUESTA)
    ) 
    TABLESPACE TS_OPCIONES_RESPUESTA
;

ALTER TABLE GRUPOS 
    ADD CONSTRAINT GRUPOS_PROFESOR_FK FOREIGN KEY (ID_PROFESOR) 
    REFERENCES PROFESORES (ID_PROFESOR) 
;

ALTER TABLE GRUPOS 
    ADD CONSTRAINT GRUPOS_MATERIA_FK FOREIGN KEY (ID_MATERIA) 
    REFERENCES MATERIAS (ID_MATERIA) 
;

ALTER TABLE GRUPO_ESTUDIANTE
    ADD CONSTRAINT ESTUDIANTE_GRUPO_ESTUDIANTE_FK FOREIGN KEY (ID_ESTUDIANTE) 
    REFERENCES ESTUDIANTES (ID_ESTUDIANTE) 
;

ALTER TABLE GRUPO_ESTUDIANTE
    ADD CONSTRAINT GRUPO_GRUPO_ESTUDIANTE_FK FOREIGN KEY (ID_GRUPO) 
    REFERENCES GRUPOS (ID_GRUPO) 
;

ALTER TABLE EXAMENES 
    ADD CONSTRAINT EXAMENES_TEMA_FK FOREIGN KEY (ID_TEMA) 
    REFERENCES TEMAS (ID_TEMA) 
;

ALTER TABLE EXAMENES 
    ADD CONSTRAINT EXAMENES_PROFESOR_FK FOREIGN KEY (ID_PROFESOR) 
    REFERENCES PROFESORES (ID_PROFESOR) 
;

ALTER TABLE EXAMENES 
    ADD CONSTRAINT EXAMENES_UNIDAD_FK FOREIGN KEY (ID_UNIDAD) 
    REFERENCES UNIDADES (ID_UNIDAD) 
;

ALTER TABLE GRUPO_EXAMEN
    ADD CONSTRAINT GRUPO_GRUPO_EXAMEN_FK FOREIGN KEY (ID_GRUPO) 
    REFERENCES GRUPOS (ID_GRUPO) 
;

ALTER TABLE GRUPO_EXAMEN
    ADD CONSTRAINT EXAMEN_GRUPO_EXAMEN_FK FOREIGN KEY (ID_EXAMEN) 
    REFERENCES EXAMENES (ID_EXAMEN) 
;

ALTER TABLE UNIDAD_GRUPO
    ADD CONSTRAINT UNIDAD_UNIDAD_GRUPO_FK FOREIGN KEY (ID_UNIDAD) 
    REFERENCES UNIDADES (ID_UNIDAD) 
;

ALTER TABLE UNIDAD_GRUPO
    ADD CONSTRAINT GRUPO_UNIDAD_GRUPO_FK FOREIGN KEY (ID_GRUPO) 
    REFERENCES GRUPOS (ID_GRUPO) 
;

ALTER TABLE PREGUNTAS 
    ADD CONSTRAINT PREGUNTAS_PRIVACIDAD_FK FOREIGN KEY (ID_PRIVACIDAD) 
    REFERENCES PRIVACIDAD (ID_PRIVACIDAD) 
;

ALTER TABLE PREGUNTAS 
    ADD CONSTRAINT PREGUNTAS_TIPO_PREGUNTA_FK FOREIGN KEY (ID_TIPO_PREGUNTA) 
    REFERENCES TIPO_PREGUNTA (ID_TIPO_PREGUNTA) 
;

ALTER TABLE PREGUNTAS 
    ADD CONSTRAINT PREGUNTAS_PREGUNTA_FK FOREIGN KEY (ID_PREGUNTA_GENERAL) 
    REFERENCES PREGUNTAS (ID_PREGUNTA) 
;

ALTER TABLE PREGUNTAS 
    ADD CONSTRAINT PREGUNTAS_PROFESOR_FK FOREIGN KEY (ID_PROFESOR) 
    REFERENCES PROFESORES (ID_PROFESOR) 
;

ALTER TABLE PREGUNTAS 
    ADD CONSTRAINT PREGUNTAS_BANCO_FK FOREIGN KEY (ID_BANCO) 
    REFERENCES BANCOS (ID_BANCO) 
;

ALTER TABLE PREGUNTA_EXAMEN
    ADD CONSTRAINT PREGUNTA_PREGUNTA_EXAMEN_FK FOREIGN KEY (ID_PREGUNTA) 
    REFERENCES PREGUNTAS (ID_PREGUNTA) 
;

ALTER TABLE PREGUNTA_EXAMEN
    ADD CONSTRAINT EXAMEN_PREGUNTA_EXAMEN_FK FOREIGN KEY (ID_EXAMEN) 
    REFERENCES EXAMENES (ID_EXAMEN) 
;

ALTER TABLE BANCOS 
    ADD CONSTRAINT BANCOS_TEMA_FK FOREIGN KEY (ID_TEMA) 
    REFERENCES TEMAS (ID_TEMA) 
;

ALTER TABLE TEMAS 
    ADD CONSTRAINT TEMAS_MATERIA_FK FOREIGN KEY (ID_MATERIA) 
    REFERENCES MATERIAS (ID_MATERIA) 
;

ALTER TABLE TEMAS 
    ADD CONSTRAINT TEMAS_BANCO_FK FOREIGN KEY (ID_BANCO) 
    REFERENCES BANCOS (ID_BANCO) 
;

ALTER TABLE OPCIONES_RESPUESTA 
    ADD CONSTRAINT OPCIONES_RESPUESTA_PREGUNTA_FK FOREIGN KEY (ID_PREGUNTA) 
    REFERENCES PREGUNTAS (ID_PREGUNTA) 
;


-- CREACIÓN DE ÍNDICES -------------------------------------------------------

CREATE INDEX IDX_ESTUDIANTES_EMAIL ON ESTUDIANTES (EMAIL) 
TABLESPACE TS_ESTUDIANTES;

CREATE INDEX IDX_PROFESORES_EMAIL ON PROFESORES (EMAIL) 
TABLESPACE TS_PROFESORES;

CREATE INDEX IDX_EXAMENES_CODIGO ON EXAMENES (CODIGO) 
TABLESPACE TS_EXAMENES;

CREATE INDEX IDX_TEMAS_NOMBRE ON TEMAS (NOMBRE) 
TABLESPACE TS_TEMAS;

CREATE INDEX IDX_MATERIAS_NOMBRE ON MATERIAS (NOMBRE) 
TABLESPACE TS_MATERIAS;


-- CREACIÓN DE ROLES ---------------------------------------------------------

CREATE ROLE ADMINISTRADOR;
GRANT ALL PRIVILEGES TO ADMINISTRADOR;

CREATE ROLE ESTUDIANTE;
GRANT SELECT, UPDATE, DELETE ON ESTUDIANTES TO ESTUDIANTE;
GRANT SELECT ON PROFESORES TO ESTUDIANTE;
GRANT SELECT ON GRUPOS TO ESTUDIANTE;
GRANT SELECT ON GRUPO_ESTUDIANTE TO ESTUDIANTE;
GRANT SELECT ON EXAMENES TO ESTUDIANTE;
GRANT SELECT ON UNIDADES TO ESTUDIANTE;
GRANT SELECT ON UNIDAD_GRUPO TO ESTUDIANTE;
GRANT SELECT ON TEMAS TO ESTUDIANTE;
GRANT SELECT ON MATERIAS TO ESTUDIANTE;

CREATE ROLE PROFESOR;
GRANT SELECT ON ESTUDIANTES TO PROFESOR;
GRANT SELECT, UPDATE, DELETE ON PROFESORES TO PROFESOR;
GRANT SELECT, INSERT, UPDATE, DELETE ON GRUPOS TO PROFESOR;
GRANT SELECT, INSERT, DELETE ON GRUPO_ESTUDIANTE TO PROFESOR;
GRANT SELECT, INSERT, UPDATE, DELETE ON EXAMENES TO PROFESOR;
GRANT SELECT, INSERT, DELETE ON GRUPO_EXAMEN TO PROFESOR;
GRANT SELECT, INSERT, UPDATE, DELETE ON UNIDADES TO PROFESOR;
GRANT SELECT, INSERT, DELETE ON UNIDAD_GRUPO TO PROFESOR;
GRANT SELECT, INSERT, UPDATE, DELETE ON PREGUNTAS TO PROFESOR;
GRANT SELECT, INSERT, DELETE ON PREGUNTA_EXAMEN TO PROFESOR;
GRANT SELECT, UPDATE ON BANCOS TO PROFESOR;
GRANT SELECT ON TEMAS TO PROFESOR;
GRANT SELECT ON MATERIAS TO PROFESOR;
GRANT SELECT ON OPCIONES_RESPUESTA TO PROFESOR;


-- FUNCIONES Y PROCEDIMIENTOS -------------------------------------------------

-------------------------- CRUD ESTUDIANTES ---------------------------------

-- REGISTRAR ESTUDIANTE
CREATE OR REPLACE PROCEDURE REGISTRAR_ESTUDIANTE (
    P_ID          IN ESTUDIANTES.id_estudiante%TYPE,
    P_NOMBRE      IN ESTUDIANTES.nombre%TYPE,
    P_APELLIDO    IN ESTUDIANTES.apellido%TYPE,
    P_EMAIL       IN ESTUDIANTES.email%TYPE,
    P_CONTRASENA  IN ESTUDIANTES.contrasena%TYPE,
    P_SEMESTRE    IN ESTUDIANTES.semestre%TYPE
) IS
    email_exists EXCEPTION;
    CURSOR_ESTUDIANTES SYS_REFCURSOR;
    v_temp ESTUDIANTES%ROWTYPE;
BEGIN
    -- Se verifica si el email ya existe
    OBTENER_ESTUDIANTE_POR_EMAIL(P_EMAIL, CURSOR_ESTUDIANTES);

    FETCH CURSOR_ESTUDIANTES INTO v_temp;
    IF CURSOR_ESTUDIANTES%FOUND THEN
        RAISE email_exists;
    END IF;

    -- Si aun no existe, se inserta el estudiante
    INSERT INTO ESTUDIANTES (
        id_estudiante, nombre, apellido, email, contrasena, semestre
    ) VALUES (
        p_id, p_nombre, p_apellido, p_email, p_contrasena, p_semestre
    );
    
    CLOSE CURSOR_ESTUDIANTES;
    
EXCEPTION
    WHEN email_exists THEN
        RAISE_APPLICATION_ERROR(-20001, 'El email ya está registrado en el sistema.');
    WHEN OTHERS THEN
        IF CURSOR_ESTUDIANTES%ISOPEN THEN
            CLOSE CURSOR_ESTUDIANTES;
        END IF;
        RAISE;
END REGISTRAR_ESTUDIANTE;


-- LISTAR TODOS LOS ESTUDIANTES
CREATE OR REPLACE PROCEDURE LISTAR_ESTUDIANTES (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM ESTUDIANTES;
END LISTAR_ESTUDIANTES;


-- OBTENER UN ESTUDIANTE POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_ESTUDIANTE_POR_ID (
    P_ID_ESTUDIANTE IN ESTUDIANTES.ID_ESTUDIANTE%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM ESTUDIANTES
  WHERE ID_ESTUDIANTE = P_ID_ESTUDIANTE;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el estudiante por ID.');
END OBTENER_ESTUDIANTE_POR_ID;


-- OBTENER UN ESTUDIANTE POR SU EMAIL
CREATE OR REPLACE PROCEDURE OBTENER_ESTUDIANTE_POR_EMAIL (
    P_EMAIL_ESTUDIANTE IN ESTUDIANTES.EMAIL%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM ESTUDIANTES
  WHERE EMAIL = P_EMAIL_ESTUDIANTE;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el estudiante por email.');
END OBTENER_ESTUDIANTE_POR_EMAIL;


-- ACTUALIZAR LA INFORMACION DE UN ESTUDIANTE
CREATE OR REPLACE PROCEDURE ACTUALIZAR_ESTUDIANTE (
    P_ID          IN ESTUDIANTES.ID_ESTUDIANTE%TYPE,
    P_NOMBRE      IN ESTUDIANTES.NOMBRE%TYPE,
    P_APELLIDO    IN ESTUDIANTES.APELLIDO%TYPE,
    P_EMAIL       IN ESTUDIANTES.EMAIL%TYPE,
    P_CONTRASENA  IN ESTUDIANTES.CONTRASENA%TYPE,
    P_SEMESTRE    IN ESTUDIANTES.SEMESTRE%TYPE
) IS
    V_CURSOR_EMAIL SYS_REFCURSOR;
    V_EXISTING_EMAIL ESTUDIANTES%ROWTYPE;
BEGIN
    -- Verificar si el nuevo email ya está registrado por otro estudiante
    OBTENER_ESTUDIANTE_POR_EMAIL(P_EMAIL, V_CURSOR_EMAIL);
    FETCH V_CURSOR_EMAIL INTO V_EXISTING_EMAIL;
    CLOSE V_CURSOR_EMAIL;

    -- Si se encontró otro estudiante con el mismo email, lanzar una excepción
    IF V_EXISTING_EMAIL.ID_ESTUDIANTE IS NOT NULL AND V_EXISTING_EMAIL.ID_ESTUDIANTE != P_ID THEN
        RAISE_APPLICATION_ERROR(-20004, 'El email especificado ya está registrado por otro estudiante.');
    END IF;

    -- Actualizar la información del estudiante si pasa las validaciones
    UPDATE ESTUDIANTES
    SET
        NOMBRE = P_NOMBRE,
        APELLIDO = P_APELLIDO,
        EMAIL = P_EMAIL,
        CONTRASENA = P_CONTRASENA,
        SEMESTRE = P_SEMESTRE
    WHERE ID_ESTUDIANTE = P_ID;
END ACTUALIZAR_ESTUDIANTE;


-- ELIMINAR UN ESTUDIANTE BUSCADO POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_ESTUDIANTE (
    P_ID_ESTUDIANTE IN ESTUDIANTES.ID_ESTUDIANTE%TYPE
) AS
BEGIN
    DELETE FROM ESTUDIANTES 
    WHERE ID_ESTUDIANTE = P_ID_ESTUDIANTE;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún estudiante con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar el estudiante.');
END ELIMINAR_ESTUDIANTE;


--------------------------- CRUD PROFESORES ----------------------------------

-- REGISTRAR PROFESOR
CREATE OR REPLACE PROCEDURE REGISTRAR_PROFESOR (
    P_ID          IN PROFESORES.id_profesor%TYPE,
    P_NOMBRE      IN PROFESORES.nombre%TYPE,
    P_APELLIDO    IN PROFESORES.apellido%TYPE,
    P_EMAIL       IN PROFESORES.email%TYPE,
    P_CONTRASENA  IN PROFESORES.contrasena%TYPE,
    P_ID_MATERIA  IN PROFESORES.id_materia%TYPE
) IS
    email_exists EXCEPTION;
    CURSOR_PROFESORES SYS_REFCURSOR;
    v_temp PROFESORES%ROWTYPE;
BEGIN
    -- Se verifica si el email ya existe
    OBTENER_PROFESOR_POR_EMAIL(P_EMAIL, CURSOR_PROFESORES);

    FETCH CURSOR_PROFESORES INTO v_temp;
    IF CURSOR_PROFESORES%FOUND THEN
        RAISE email_exists;
    END IF;

    INSERT INTO PROFESORES (
        id_profesor, nombre, apellido, email, contrasena, id_materia
    ) VALUES (
        p_id, p_nombre, p_apellido, p_email, p_contrasena, p_id_materia
    );
    CLOSE CURSOR_PROFESORES;
    
EXCEPTION
    WHEN email_exists THEN
        RAISE_APPLICATION_ERROR(-20001, 'El email ya está registrado en el sistema.');
    WHEN OTHERS THEN
        IF CURSOR_PROFESORES%ISOPEN THEN
            CLOSE CURSOR_PROFESORES;
        END IF;
        RAISE;
END REGISTRAR_PROFESOR;


-- LISTAR TODOS LOS PROFESORES
CREATE OR REPLACE PROCEDURE LISTAR_PROFESORES (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT P.ID_PROFESOR, P.NOMBRE, P.APELLIDO, P.EMAIL, P.CONTRASENA, M.NOMBRE
  FROM PROFESORES P
  JOIN MATERIAS M ON P.ID_MATERIA = M.ID_MATERIA;
END LISTAR_PROFESORES;


-- OBTENER UN PROFESOR POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_PROFESOR_POR_ID (
    P_ID_PROFESOR IN PROFESORES.ID_PROFESOR%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT P.ID_PROFESOR, P.NOMBRE, P.APELLIDO, P.EMAIL, P.CONTRASENA, M.NOMBRE AS NOMBRE_MATERIA
  FROM PROFESORES P
  JOIN MATERIAS M ON P.ID_MATERIA = M.ID_MATERIA
  WHERE P.ID_PROFESOR = P_ID_PROFESOR;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el profesor por ID.');
END OBTENER_PROFESOR_POR_ID;


-- OBTENER UN PROFESOR POR SU EMAIL
CREATE OR REPLACE PROCEDURE OBTENER_PROFESOR_POR_EMAIL (
    P_EMAIL IN PROFESORES.EMAIL%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT P.ID_PROFESOR, P.NOMBRE, P.APELLIDO, P.EMAIL, P.CONTRASENA, M.NOMBRE
  FROM PROFESORES P
  JOIN MATERIAS M ON P.ID_MATERIA = M.ID_MATERIA
  WHERE P.EMAIL = P_EMAIL;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el profesor por email.');
END OBTENER_PROFESOR_POR_EMAIL;


-- ACTUALIZAR LA INFORMACION DE UN PROFESOR
CREATE OR REPLACE PROCEDURE ACTUALIZAR_PROFESOR (
    P_ID          IN PROFESORES.ID_PROFESOR%TYPE,
    P_NOMBRE      IN PROFESORES.NOMBRE%TYPE,
    P_APELLIDO    IN PROFESORES.APELLIDO%TYPE,
    P_EMAIL       IN PROFESORES.EMAIL%TYPE,
    P_CONTRASENA  IN PROFESORES.CONTRASENA%TYPE,
    P_ID_MATERIA  IN PROFESORES.ID_MATERIA%TYPE
) IS
    V_CURSOR_EMAIL SYS_REFCURSOR;
    V_EXISTING_EMAIL PROFESORES%ROWTYPE;
BEGIN
    -- Verificar si el nuevo email ya está registrado por otro profesor
    OBTENER_PROFESOR_POR_EMAIL(P_EMAIL, V_CURSOR_EMAIL);
    FETCH V_CURSOR_EMAIL INTO V_EXISTING_EMAIL;
    CLOSE V_CURSOR_EMAIL;

    -- Si se encontró otro profesor con el mismo email, lanzar una excepción
    IF V_EXISTING_EMAIL.ID_PROFESOR IS NOT NULL AND V_EXISTING_EMAIL.ID_PROFESOR != P_ID THEN
        RAISE_APPLICATION_ERROR(-20004, 'El email especificado ya está registrado por otro profesor.');
    END IF;

    -- Actualizar la información del profesor si pasa las validaciones
    UPDATE PROFESORES
    SET
        NOMBRE = P_NOMBRE,
        APELLIDO = P_APELLIDO,
        EMAIL = P_EMAIL,
        CONTRASENA = P_CONTRASENA,
        ID_MATERIA = P_ID_MATERIA
    WHERE ID_PROFESOR = P_ID;
END ACTUALIZAR_PROFESOR;


-- ELIMINAR UN PROFESOR BUSCADO POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_PROFESOR (
    P_ID IN PROFESORES.ID_PROFESOR%TYPE
) AS
BEGIN
    DELETE FROM PROFESORES 
    WHERE ID_PROFESOR = P_ID;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún profesor con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar el profesor.');
END ELIMINAR_PROFESOR;


--------------------------- CRUD MATERIAS ------------------------------------

-- CREAR MATERIA
CREATE OR REPLACE PROCEDURE CREAR_MATERIA (
    P_ID           IN MATERIAS.ID_MATERIA%TYPE,
    P_NOMBRE       IN MATERIAS.NOMBRE%TYPE,
    P_HORAS_SEMANA IN MATERIAS.HORAS_SEMANA%TYPE,
    P_CREDITOS     IN MATERIAS.CREDITOS%TYPE
) IS
    name_exists EXCEPTION;
    CURSOR_MATERIAS SYS_REFCURSOR;
    v_temp MATERIAS%ROWTYPE;
BEGIN
    -- Se verifica si el nombre ya existe
    OBTENER_MATERIA_POR_NOMBRE(P_NOMBRE, CURSOR_MATERIAS);

    FETCH CURSOR_MATERIAS INTO v_temp;
    IF CURSOR_MATERIAS%FOUND THEN
        RAISE name_exists;
    END IF;

    INSERT INTO MATERIAS (
        ID_MATERIA, NOMBRE, HORAS_SEMANA, CREDITOS
    ) VALUES (
        P_ID, P_NOMBRE, P_HORAS_SEMANA, P_CREDITOS
    );
    
    CLOSE CURSOR_MATERIAS;
    
EXCEPTION
    WHEN name_exists THEN
        RAISE_APPLICATION_ERROR(-20011, 'El nombre de la materia ya está registrado en el sistema.');
    WHEN OTHERS THEN
        IF CURSOR_MATERIAS%ISOPEN THEN
            CLOSE CURSOR_MATERIAS;
        END IF;
        RAISE;    
END CREAR_MATERIA;


-- LISTAR TODAS LAS MATERIAS
CREATE OR REPLACE PROCEDURE LISTAR_MATERIAS (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM MATERIAS;
END LISTAR_MATERIAS;


-- OBTENER UNA MATERIA POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_MATERIA_POR_ID (
    P_ID IN MATERIAS.ID_MATERIA%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM MATERIAS
  WHERE ID_MATERIA = P_ID;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener la materia por ID.');
END OBTENER_MATERIA_POR_ID;


-- OBTENER UNA MATERIA POR SU NOMBRE
CREATE OR REPLACE PROCEDURE OBTENER_MATERIA_POR_NOMBRE (
    P_NOMBRE IN MATERIAS.NOMBRE%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM MATERIAS
  WHERE NOMBRE = P_NOMBRE;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener la materia por email.');
END OBTENER_MATERIA_POR_NOMBRE;


-- ACTUALIZAR LA INFORMACION DE UNA MATERIA
CREATE OR REPLACE PROCEDURE ACTUALIZAR_MATERIA (
    P_ID           IN MATERIAS.ID_MATERIA%TYPE,
    P_NOMBRE       IN MATERIAS.NOMBRE%TYPE,
    P_HORAS_SEMANA IN MATERIAS.HORAS_SEMANA%TYPE,
    P_CREDITOS     IN MATERIAS.CREDITOS%TYPE
) IS
    V_CURSOR_NOMBRE SYS_REFCURSOR;
    V_EXISTING_NOMBRE MATERIAS%ROWTYPE;
BEGIN
    -- Verificar si el nuevo nombre ya está registrado por otra materia
    OBTENER_MATERIA_POR_NOMBRE(P_NOMBRE, V_CURSOR_NOMBRE);
    FETCH V_CURSOR_NOMBRE INTO V_EXISTING_NOMBRE;
    CLOSE V_CURSOR_NOMBRE;

    -- Si se encontró otra materia con el mismo nombre, lanzar una excepción
    IF V_EXISTING_NOMBRE.ID_MATERIA IS NOT NULL AND V_EXISTING_NOMBRE.ID_MATERIA != P_ID THEN
        RAISE_APPLICATION_ERROR(-20004, 'El nombre especificado ya está registrado por otra materia.');
    END IF;

    -- Actualizar la información de la materia si pasa las validaciones
    UPDATE MATERIAS
    SET
        NOMBRE = P_NOMBRE,
        HORAS_SEMANA = P_HORAS_SEMANA,
        CREDITOS = P_CREDITOS
    WHERE ID_MATERIA = P_ID;
END ACTUALIZAR_MATERIA;


-- ELIMINAR UNA MATERIA BUSCADA POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_MATERIA (
    P_ID IN MATERIAS.ID_MATERIA%TYPE
) AS
BEGIN
    DELETE FROM MATERIAS 
    WHERE ID_MATERIA = P_ID;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ninguna materia con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar la materia.');
END ELIMINAR_MATERIA;


--------------------------- CRUD TIPO_PREGUNTA --------------------------------

-- CREAR TIPO DE PREGUNTA
CREATE OR REPLACE PROCEDURE CREAR_TIPO_PREGUNTA (
    P_ID          IN TIPO_PREGUNTA.ID_TIPO_PREGUNTA%TYPE,
    P_TIPO        IN TIPO_PREGUNTA.TIPO%TYPE,
    P_DESCRIPCION IN TIPO_PREGUNTA.DESCRIPCION%TYPE
) IS
BEGIN
    INSERT INTO TIPO_PREGUNTA (
        ID_TIPO_PREGUNTA, TIPO, DESCRIPCION
    ) VALUES (
        P_ID, P_TIPO, P_DESCRIPCION
    );
END CREAR_TIPO_PREGUNTA;


-- LISTAR TODOS LOS TIPOS DE PREGUNTA
CREATE OR REPLACE PROCEDURE LISTAR_TIPOS_PREGUNTA (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM TIPO_PREGUNTA;
END LISTAR_TIPOS_PREGUNTA;


-- OBTENER UN TIPO DE PREGUNTA POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_TIPO_PREGUNTA_POR_ID (
    P_ID IN TIPO_PREGUNTA.ID_TIPO_PREGUNTA%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM TIPO_PREGUNTA
  WHERE ID_TIPO_PREGUNTA = P_ID;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el tipo de pregunta por ID.');
END OBTENER_TIPO_PREGUNTA_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UN TIPO DE PREGUNTA
CREATE OR REPLACE PROCEDURE ACTUALIZAR_TIPO_PREGUNTA (
    P_ID          IN TIPO_PREGUNTA.ID_TIPO_PREGUNTA%TYPE,
    P_TIPO        IN TIPO_PREGUNTA.TIPO%TYPE,
    P_DESCRIPCION IN TIPO_PREGUNTA.DESCRIPCION%TYPE
) IS
BEGIN
    UPDATE TIPO_PREGUNTA
    SET
        TIPO        = P_TIPO,
        DESCRIPCION = P_DESCRIPCION
    WHERE ID_TIPO_PREGUNTA = P_ID;
END ACTUALIZAR_TIPO_PREGUNTA;


-- ELIMINAR UN TIPO DE PREGUNTA BUSCADO POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_TIPO_PREGUNTA (
    P_ID IN TIPO_PREGUNTA.ID_TIPO_PREGUNTA%TYPE
) AS
BEGIN
    DELETE FROM TIPO_PREGUNTA 
    WHERE ID_TIPO_PREGUNTA = P_ID;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún tipo de pregunta con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar el tipo de pregunta.');
END ELIMINAR_TIPO_PREGUNTA;


------------------------------ CRUD TEMAS ------------------------------------

-- CREAR TEMA
CREATE OR REPLACE PROCEDURE CREAR_TEMA (
    P_ID         IN TEMAS.ID_TEMA%TYPE,
    P_NOMBRE     IN TEMAS.NOMBRE%TYPE,
    P_ID_MATERIA IN TEMAS.ID_MATERIA%TYPE
) IS
BEGIN
    -- Creación del tema
    INSERT INTO TEMAS (
        ID_TEMA, NOMBRE, ID_MATERIA
    ) VALUES (
        P_ID, P_NOMBRE, P_ID_MATERIA
    );
    
    -- Creación del banco de preguntas asociado al tema
    INSERT INTO BANCOS (
        ID_BANCO, NOMBRE, ID_TEMA
    ) VALUES (
        P_ID, P_NOMBRE, P_ID
    );
    
    -- Asociación del tema con su nuevo banco de preguntas
    UPDATE TEMAS
    SET ID_BANCO = P_ID
    WHERE ID_TEMA = P_ID;
END CREAR_TEMA;


-- LISTAR TODOS LOS TEMAS
CREATE OR REPLACE PROCEDURE LISTAR_TEMAS (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT T.ID_TEMA, T.NOMBRE, M.NOMBRE AS MATERIA, B.NOMBRE AS BANCO
  FROM TEMAS T
  JOIN MATERIAS M ON T.ID_MATERIA = M.ID_MATERIA
  JOIN BANCOS   B ON T.ID_BANCO   = B.ID_BANCO;
END LISTAR_TEMAS;


-- OBTENER UN TEMA POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_TEMA_POR_ID (
    P_ID IN TEMAS.ID_TEMA%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT T.ID_TEMA, T.NOMBRE, M.NOMBRE AS MATERIA, B.NOMBRE AS BANCO
  FROM TEMAS T
  JOIN MATERIAS M ON T.ID_MATERIA = M.ID_MATERIA
  JOIN BANCOS   B ON T.ID_BANCO   = B.ID_BANCO
  WHERE T.ID_TEMA = P_ID;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el profesor por ID.');
END OBTENER_TEMA_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UN TEMA
CREATE OR REPLACE PROCEDURE ACTUALIZAR_TEMA (
    P_ID         IN TEMAS.ID_TEMA%TYPE,
    P_NOMBRE     IN TEMAS.NOMBRE%TYPE,
    P_ID_MATERIA IN TEMAS.ID_MATERIA%TYPE
) IS
BEGIN
    UPDATE TEMAS
    SET
        NOMBRE = P_NOMBRE,
        ID_MATERIA = P_ID_MATERIA
    WHERE ID_TEMA = P_ID;
    
    -- Actualizar banco asociado
    UPDATE BANCOS
    SET NOMBRE = P_NOMBRE
    WHERE ID_BANCO = P_ID;
END ACTUALIZAR_TEMA;


-- ELIMINAR UN TEMA BUSCADO POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_TEMA (
    P_ID IN TEMAS.ID_TEMA%TYPE
) AS
BEGIN
    DELETE FROM TEMAS 
    WHERE ID_TEMA = P_ID;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún tema con el ID especificado.');
    END IF;
    
    -- Eliminar banco asociado
    DELETE FROM BANCOS 
    WHERE ID_BANCO = P_ID;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún banco con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar el tema.');
END ELIMINAR_TEMA;


----------------------------- CRUD PREGUNTAS ---------------------------------

-- CREAR PREGUNTA
CREATE OR REPLACE PROCEDURE CREAR_PREGUNTA (
    P_ID                     IN PREGUNTAS.ID_PREGUNTA%TYPE,
    P_TEXTO_PREGUNTA         IN PREGUNTAS.TEXTO_PREGUNTA%TYPE,
    P_PORCENTAJE_GENERAL     IN PREGUNTAS.PORCENTAJE_GENERAL%TYPE,
    P_PORCENTAJE_SUBPREGUNTA IN PREGUNTAS.PORCENTAJE_SUBPREGUNTA%TYPE,
    P_TIEMPO                 IN PREGUNTAS.TIEMPO%TYPE,
    P_ID_PRIVACIDAD          IN PREGUNTAS.ID_PRIVACIDAD%TYPE,
    P_ID_TIPO_PREGUNTA       IN PREGUNTAS.ID_TIPO_PREGUNTA%TYPE,
    P_ID_PREGUNTA_GENERAL    IN PREGUNTAS.ID_PREGUNTA_GENERAL%TYPE,
    P_ID_PROFESOR            IN PREGUNTAS.ID_PROFESOR%TYPE,
    P_ID_BANCO               IN PREGUNTAS.ID_BANCO%TYPE
) IS
BEGIN
    INSERT INTO PREGUNTAS (
        ID_PREGUNTA, 
        TEXTO_PREGUNTA, 
        PORCENTAJE_GENERAL, 
        PORCENTAJE_SUBPREGUNTA, 
        TIEMPO, 
        ID_PRIVACIDAD, 
        ID_TIPO_PREGUNTA, 
        ID_PREGUNTA_GENERAL, 
        ID_PROFESOR, 
        ID_BANCO
    ) VALUES (
        P_ID, 
        P_TEXTO_PREGUNTA, 
        P_PORCENTAJE_GENERAL, 
        P_PORCENTAJE_SUBPREGUNTA, 
        P_TIEMPO, 
        P_ID_PRIVACIDAD, 
        P_ID_TIPO_PREGUNTA, 
        P_ID_PREGUNTA_GENERAL, 
        P_ID_PROFESOR, 
        P_ID_BANCO
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al crear la pregunta.');
END CREAR_PREGUNTA;


-- LISTAR TODAS LAS PREGUNTAS
CREATE OR REPLACE PROCEDURE LISTAR_PREGUNTAS (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT 
    P.ID_PREGUNTA,
    P.TEXTO_PREGUNTA,
    P.PORCENTAJE_GENERAL,
    P.PORCENTAJE_SUBPREGUNTA,
    P.TIEMPO,
    PR.TIPO AS TIPO_PRIVACIDAD,
    TP.TIPO AS TIPO_PREGUNTA,
    P.ID_PREGUNTA_GENERAL AS PREGUNTA_GENERAL,
    PROF.NOMBRE || ' ' || PROF.APELLIDO AS NOMBRE_PROFESOR,
    B.NOMBRE AS NOMBRE_BANCO
  FROM 
    PREGUNTAS P
    JOIN PRIVACIDAD PR ON P.ID_PRIVACIDAD = PR.ID_PRIVACIDAD
    JOIN TIPO_PREGUNTA TP ON P.ID_TIPO_PREGUNTA = TP.ID_TIPO_PREGUNTA
    JOIN PROFESORES PROF ON P.ID_PROFESOR = PROF.ID_PROFESOR
    JOIN BANCOS B ON P.ID_BANCO = B.ID_BANCO;
END LISTAR_PREGUNTAS;


-- OBTENER UNA PREGUNTA POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_PREGUNTA_POR_ID (
    P_ID_PREGUNTA IN PREGUNTAS.ID_PREGUNTA%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT 
    P.ID_PREGUNTA,
    P.TEXTO_PREGUNTA,
    P.PORCENTAJE_GENERAL,
    P.PORCENTAJE_SUBPREGUNTA,
    P.TIEMPO,
    PR.TIPO AS TIPO_PRIVACIDAD,
    TP.TIPO AS TIPO_PREGUNTA,
    P.ID_PREGUNTA_GENERAL AS PREGUNTA_GENERAL,
    PROF.NOMBRE || ' ' || PROF.APELLIDO AS NOMBRE_PROFESOR,
    B.NOMBRE AS NOMBRE_BANCO
  FROM 
    PREGUNTAS P
    JOIN PRIVACIDAD PR ON P.ID_PRIVACIDAD = PR.ID_PRIVACIDAD
    JOIN TIPO_PREGUNTA TP ON P.ID_TIPO_PREGUNTA = TP.ID_TIPO_PREGUNTA
    JOIN PROFESORES PROF ON P.ID_PROFESOR = PROF.ID_PROFESOR
    JOIN BANCOS B ON P.ID_BANCO = B.ID_BANCO
  WHERE 
    P.ID_PREGUNTA = P_ID_PREGUNTA;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener la pregunta por ID.');
END OBTENER_PREGUNTA_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UNA PREGUNTA
CREATE OR REPLACE PROCEDURE ACTUALIZAR_PREGUNTA (
    P_ID                     IN PREGUNTAS.ID_PREGUNTA%TYPE,
    P_TEXTO_PREGUNTA         IN PREGUNTAS.TEXTO_PREGUNTA%TYPE,
    P_PORCENTAJE_GENERAL     IN PREGUNTAS.PORCENTAJE_GENERAL%TYPE,
    P_PORCENTAJE_SUBPREGUNTA IN PREGUNTAS.PORCENTAJE_SUBPREGUNTA%TYPE,
    P_TIEMPO                 IN PREGUNTAS.TIEMPO%TYPE,
    P_ID_PRIVACIDAD          IN PREGUNTAS.ID_PRIVACIDAD%TYPE,
    P_ID_TIPO_PREGUNTA       IN PREGUNTAS.ID_TIPO_PREGUNTA%TYPE,
    P_ID_PREGUNTA_GENERAL    IN PREGUNTAS.ID_PREGUNTA_GENERAL%TYPE,
    P_ID_PROFESOR            IN PREGUNTAS.ID_PROFESOR%TYPE,
    P_ID_BANCO               IN PREGUNTAS.ID_BANCO%TYPE
) IS
    V_CURSOR SYS_REFCURSOR;
    V_EXISTING_PREGUNTA PREGUNTAS%ROWTYPE;
    V_EXISTING_PRIVACIDAD PRIVACIDAD%ROWTYPE;
    V_EXISTING_TIPO_PREGUNTA TIPO_PREGUNTA%ROWTYPE;
    V_EXISTING_PROFESOR PROFESORES%ROWTYPE;
    V_EXISTING_BANCO BANCOS%ROWTYPE;
BEGIN
    -- Verificar si la pregunta existe por ID
    OBTENER_PREGUNTA_POR_ID(P_ID, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_PREGUNTA;
    CLOSE V_CURSOR;

    IF V_EXISTING_PREGUNTA.ID_PREGUNTA IS NULL THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ninguna pregunta con el ID especificado.');
    END IF;

    -- Verificar si la privacidad existe
    OBTENER_PRIVACIDAD_POR_ID(P_ID_PRIVACIDAD, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_PRIVACIDAD;
    CLOSE V_CURSOR;

    IF V_EXISTING_PRIVACIDAD.ID_PRIVACIDAD IS NULL THEN
        RAISE_APPLICATION_ERROR(-20005, 'No se encontró ninguna privacidad con el ID especificado.');
    END IF;

    -- Verificar si el tipo de pregunta existe
    OBTENER_TIPO_PREGUNTA_POR_ID(P_ID_TIPO_PREGUNTA, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_TIPO_PREGUNTA;
    CLOSE V_CURSOR;

    IF V_EXISTING_TIPO_PREGUNTA.ID_TIPO_PREGUNTA IS NULL THEN
        RAISE_APPLICATION_ERROR(-20006, 'No se encontró ningún tipo de pregunta con el ID especificado.');
    END IF;

    -- Verificar si el profesor existe
    OBTENER_PROFESOR_POR_ID(P_ID_PROFESOR, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_PROFESOR;
    CLOSE V_CURSOR;

    IF V_EXISTING_PROFESOR.ID_PROFESOR IS NULL THEN
        RAISE_APPLICATION_ERROR(-20007, 'No se encontró ningún profesor con el ID especificado.');
    END IF;

    -- Verificar si el banco de preguntas existe
    OBTENER_BANCO_POR_ID(P_ID_BANCO, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_BANCO;
    CLOSE V_CURSOR;

    IF V_EXISTING_BANCO.ID_BANCO IS NULL THEN
        RAISE_APPLICATION_ERROR(-20008, 'No se encontró ningún banco de preguntas con el ID especificado.');
    END IF;

    -- Actualizar la información de la pregunta si pasa las validaciones
    UPDATE PREGUNTAS
    SET
        TEXTO_PREGUNTA = P_TEXTO_PREGUNTA,
        PORCENTAJE_GENERAL = P_PORCENTAJE_GENERAL,
        PORCENTAJE_SUBPREGUNTA = P_PORCENTAJE_SUBPREGUNTA,
        TIEMPO = P_TIEMPO,
        ID_PRIVACIDAD = P_ID_PRIVACIDAD,
        ID_TIPO_PREGUNTA = P_ID_TIPO_PREGUNTA,
        ID_PREGUNTA_GENERAL = P_ID_PREGUNTA_GENERAL,
        ID_PROFESOR = P_ID_PROFESOR,
        ID_BANCO = P_ID_BANCO
    WHERE ID_PREGUNTA = P_ID;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al actualizar la información de la pregunta.');
END ACTUALIZAR_PREGUNTA;


-- OBTENER PRIVACIDAD DE PREGUNTA POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_PRIVACIDAD_POR_ID (
    P_ID IN PRIVACIDAD.ID_PRIVACIDAD%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM PRIVACIDAD
  WHERE ID_PRIVACIDAD = P_ID;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el tipo de privacidad  por ID.');
END OBTENER_PRIVACIDAD_POR_ID;


-- OBTENER BANCO DE PREGUNTAS POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_BANCO_POR_ID (
    P_ID IN BANCOS.ID_BANCO%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM BANCOS
  WHERE ID_BANCO = P_ID;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener el banco  por ID.');
END OBTENER_BANCO_POR_ID;


-- ELIMINAR UNA PREGUNTA POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_PREGUNTA (
    P_ID IN PREGUNTAS.ID_PREGUNTA%TYPE
) IS
    V_CURSOR SYS_REFCURSOR;
    V_EXISTING_PREGUNTA PREGUNTAS%ROWTYPE;
BEGIN
    -- Verificar si la pregunta existe por ID
    OBTENER_PREGUNTA_POR_ID(P_ID, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_PREGUNTA;
    CLOSE V_CURSOR;

    IF V_EXISTING_PREGUNTA.ID_PREGUNTA IS NULL THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ninguna pregunta con el ID especificado.');
    END IF;

    -- Eliminar la pregunta
    DELETE FROM PREGUNTAS 
    WHERE ID_PREGUNTA = P_ID;
    
    -- Verificar si la eliminación fue exitosa
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ninguna pregunta con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar la pregunta.');
END ELIMINAR_PREGUNTA;


----------------------------- CRUD UNIDADES -----------------------------------

-- CREAR UNIDAD
CREATE OR REPLACE PROCEDURE CREAR_UNIDAD (
    P_ID_UNIDAD IN UNIDADES.ID_UNIDAD%TYPE,
    P_NOMBRE    IN UNIDADES.NOMBRE%TYPE,
    P_ID_GRUPO  IN GRUPOS.ID_GRUPO%TYPE
) IS
BEGIN
    INSERT INTO UNIDADES (ID_UNIDAD, NOMBRE) 
    VALUES (P_ID_UNIDAD, P_NOMBRE);
    
    -- Actualizar tabla intermedia
    INSERT INTO  UNIDAD_GRUPO (ID_UNIDAD, ID_GRUPO)
    VALUES (P_ID_UNIDAD, P_ID_GRUPO);
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ocurrió un error al crear la unidad.');
END CREAR_UNIDAD;


-- LISTAR TODAS LAS UNIDADES
CREATE OR REPLACE PROCEDURE LISTAR_UNIDADES (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM UNIDADES;
END LISTAR_UNIDADES;


-- OBTENER UNA UNIDAD POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_UNIDAD_POR_ID (
    P_ID_UNIDAD IN UNIDADES.ID_UNIDAD%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT * FROM UNIDADES
  WHERE ID_UNIDAD = P_ID_UNIDAD;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener la unidad por ID.');
END OBTENER_UNIDAD_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UNA UNIDAD
CREATE OR REPLACE PROCEDURE ACTUALIZAR_UNIDAD (
    P_ID_UNIDAD IN UNIDADES.ID_UNIDAD%TYPE,
    P_NOMBRE IN UNIDADES.NOMBRE%TYPE
) IS
BEGIN
    -- Actualizar la información de la unidad
    UPDATE UNIDADES
    SET
        NOMBRE = P_NOMBRE
    WHERE ID_UNIDAD = P_ID_UNIDAD;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al actualizar la información de la unidad.');
END ACTUALIZAR_UNIDAD;


-- ELIMINAR UNA UNIDAD POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_UNIDAD (
    P_ID_UNIDAD IN UNIDADES.ID_UNIDAD%TYPE
) AS
BEGIN
    -- Eliminar la unidad
    DELETE FROM UNIDADES 
    WHERE ID_UNIDAD = P_ID_UNIDAD;
    
    -- Verificar si la eliminación fue exitosa
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ninguna unidad con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar la unidad.');
END ELIMINAR_UNIDAD;


----------------------------- CRUD GRUPOS ------------------------------------

-- CREAR GRUPO
CREATE OR REPLACE PROCEDURE CREAR_GRUPO (
    P_ID_GRUPO    IN GRUPOS.ID_GRUPO%TYPE,
    P_NOMBRE      IN GRUPOS.NOMBRE%TYPE,
    P_ID_PROFESOR IN GRUPOS.ID_PROFESOR%TYPE,
    P_ID_MATERIA  IN GRUPOS.ID_MATERIA%TYPE,
    P_SALON_CLASE IN GRUPOS.SALON_CLASE%TYPE
) IS
BEGIN
    INSERT INTO GRUPOS (
        ID_GRUPO, NOMBRE, ID_PROFESOR, ID_MATERIA, SALON_CLASE
    ) VALUES (
        P_ID_GRUPO, P_NOMBRE, P_ID_PROFESOR, P_ID_MATERIA, P_SALON_CLASE
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ocurrió un error al crear el grupo.');
END CREAR_GRUPO;


-- LISTAR TODOS LOS GRUPOS
CREATE OR REPLACE PROCEDURE LISTAR_GRUPOS (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT * FROM GRUPOS;
END LISTAR_GRUPOS;


-- OBTENER GRUPO POR ID
CREATE OR REPLACE PROCEDURE OBTENER_GRUPO_POR_ID (
    P_ID_GRUPO IN GRUPOS.ID_GRUPO%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT * FROM GRUPOS
    WHERE ID_GRUPO = P_ID_GRUPO;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20002, 'Ocurrió un error al obtener el grupo por ID.');
END OBTENER_GRUPO_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UN GRUPO
CREATE OR REPLACE PROCEDURE ACTUALIZAR_GRUPO (
    P_ID_GRUPO    IN GRUPOS.ID_GRUPO%TYPE,
    P_NOMBRE      IN GRUPOS.NOMBRE%TYPE,
    P_ID_PROFESOR IN GRUPOS.ID_PROFESOR%TYPE,
    P_ID_MATERIA  IN GRUPOS.ID_MATERIA%TYPE,
    P_SALON_CLASE IN GRUPOS.SALON_CLASE%TYPE
) IS
BEGIN
    UPDATE GRUPOS
    SET
        NOMBRE = P_NOMBRE,
        ID_PROFESOR = P_ID_PROFESOR,
        ID_MATERIA = P_ID_MATERIA,
        SALON_CLASE = P_SALON_CLASE
    WHERE ID_GRUPO = P_ID_GRUPO;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'No se encontró ningún grupo con el ID especificado.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20004, 'Ocurrió un error al actualizar el grupo.');
END ACTUALIZAR_GRUPO;


-- ELIMINAR UN GRUPO
CREATE OR REPLACE PROCEDURE ELIMINAR_GRUPO (
    P_ID_GRUPO IN GRUPOS.ID_GRUPO%TYPE
) AS
BEGIN
    DELETE FROM GRUPOS
    WHERE ID_GRUPO = P_ID_GRUPO;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20005, 'No se encontró ningún grupo con el ID especificado.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20006, 'Ocurrió un error al eliminar el grupo.');
END ELIMINAR_GRUPO;


----------------------------- CRUD EXAMENES -----------------------------------

-- CREAR EXAMEN
CREATE OR REPLACE PROCEDURE CREAR_EXAMEN (
    P_ID                         IN EXAMENES.ID_EXAMEN%TYPE,
    P_NOMBRE                     IN EXAMENES.NOMBRE%TYPE,
    P_DESCRIPCION                IN EXAMENES.DESCRIPCION%TYPE,
    P_CODIGO                     IN EXAMENES.CODIGO%TYPE,
    P_TIEMPO                     IN EXAMENES.TIEMPO%TYPE,
    P_CANTIDAD_PREGUNTAS_ALUMNOS IN EXAMENES.CANTIDAD_PREGUNTAS_ALUMNOS%TYPE,
    P_CANTIDAD_PREGUNTAS_BANCO   IN EXAMENES.CANTIDAD_PREGUNTAS_BANCO%TYPE,
    P_FECHA                      IN EXAMENES.FECHA%TYPE,
    P_PORCENTAJE_NOTA_FINAL      IN EXAMENES.PORCENTAJE_NOTA_FINAL%TYPE,
    P_UMBRAL_APROBACION          IN EXAMENES.UMBRAL_APROBACION%TYPE,
    P_ID_TEMA                    IN EXAMENES.ID_TEMA%TYPE,
    P_ID_PROFESOR                IN EXAMENES.ID_PROFESOR%TYPE,
    P_ID_UNIDAD                  IN EXAMENES.ID_UNIDAD%TYPE,
    P_ID_GRUPO                   IN GRUPOS.ID_GRUPO%TYPE
) IS
    V_PROFESOR_EXISTE NUMBER;
    V_UNIDAD_EXISTE NUMBER;
    V_TEMA_EXISTE NUMBER;
    V_GRUPO_EXISTE NUMBER;
BEGIN
    -- Verificar si el profesor existe
    SELECT COUNT(*)
    INTO V_PROFESOR_EXISTE
    FROM PROFESORES
    WHERE ID_PROFESOR = P_ID_PROFESOR;

    IF V_PROFESOR_EXISTE = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El profesor especificado no existe.');
    END IF;

    -- Verificar si la unidad existe
    SELECT COUNT(*)
    INTO V_UNIDAD_EXISTE
    FROM UNIDADES
    WHERE ID_UNIDAD = P_ID_UNIDAD;

    IF V_UNIDAD_EXISTE = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'La unidad especificada no existe.');
    END IF;

    -- Verificar si el tema existe
    SELECT COUNT(*)
    INTO V_TEMA_EXISTE
    FROM TEMAS
    WHERE ID_TEMA = P_ID_TEMA;

    IF V_TEMA_EXISTE = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'El tema especificado no existe.');
    END IF;
    
    -- Verificar si el grupo existe
    SELECT COUNT(*)
    INTO V_GRUPO_EXISTE
    FROM GRUPOS
    WHERE ID_GRUPO = P_ID_GRUPO;

    IF V_GRUPO_EXISTE = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'El grupo especificado no existe.');
    END IF;

    INSERT INTO EXAMENES (
        ID_EXAMEN, NOMBRE, DESCRIPCION, CODIGO, TIEMPO, CANTIDAD_PREGUNTAS_ALUMNOS,
        CANTIDAD_PREGUNTAS_BANCO, FECHA, PORCENTAJE_NOTA_FINAL, UMBRAL_APROBACION,
        ID_TEMA, ID_PROFESOR, ID_UNIDAD
    ) VALUES (
        P_ID, P_NOMBRE, P_DESCRIPCION, P_CODIGO, P_TIEMPO, P_CANTIDAD_PREGUNTAS_ALUMNOS,
        P_CANTIDAD_PREGUNTAS_BANCO, P_FECHA, P_PORCENTAJE_NOTA_FINAL, P_UMBRAL_APROBACION,
        P_ID_TEMA, P_ID_PROFESOR, P_ID_UNIDAD
    );
    
    INSERT INTO GRUPO_EXAMEN (ID_GRUPO, ID_EXAMEN) 
    VALUES (P_ID_GRUPO, P_ID);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al crear el examen.');
END CREAR_EXAMEN;


-- LISTAR TODOS LOS EXAMENES
CREATE OR REPLACE PROCEDURE LISTAR_EXAMENES (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT 
        E.ID_EXAMEN, 
        E.NOMBRE, 
        E.DESCRIPCION, 
        E.CODIGO, 
        E.TIEMPO, 
        E.CANTIDAD_PREGUNTAS_ALUMNOS, 
        E.CANTIDAD_PREGUNTAS_BANCO, 
        E.FECHA, 
        E.PORCENTAJE_NOTA_FINAL, 
        E.UMBRAL_APROBACION,
        T.NOMBRE AS TEMA, 
        P.NOMBRE || ' ' || P.APELLIDO AS PROFESOR,
        U.NOMBRE AS UNIDAD
    FROM EXAMENES E
    JOIN TEMAS T ON E.ID_TEMA = T.ID_TEMA
    JOIN PROFESORES P ON E.ID_PROFESOR = P.ID_PROFESOR
    JOIN UNIDADES U ON E.ID_UNIDAD = U.ID_UNIDAD;
END LISTAR_EXAMENES;


-- OBTENER EXAMEN POR ID
CREATE OR REPLACE PROCEDURE OBTENER_EXAMEN_POR_ID (
    P_ID_EXAMEN IN EXAMENES.ID_EXAMEN%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT 
        E.ID_EXAMEN, 
        E.NOMBRE, 
        E.DESCRIPCION, 
        E.CODIGO, 
        E.TIEMPO, 
        E.CANTIDAD_PREGUNTAS_ALUMNOS, 
        E.CANTIDAD_PREGUNTAS_BANCO, 
        E.FECHA, 
        E.PORCENTAJE_NOTA_FINAL, 
        E.UMBRAL_APROBACION,
        T.NOMBRE AS TEMA, 
        P.NOMBRE || ' ' || P.APELLIDO AS PROFESOR,
        U.NOMBRE AS UNIDAD
    FROM EXAMENES E
    JOIN TEMAS T ON E.ID_TEMA = T.ID_TEMA
    JOIN PROFESORES P ON E.ID_PROFESOR = P.ID_PROFESOR
    JOIN UNIDADES U ON E.ID_UNIDAD = U.ID_UNIDAD
    WHERE E.ID_EXAMEN = P_ID_EXAMEN;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener la pregunta por ID.');
END OBTENER_EXAMEN_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UN EXAMEN
CREATE OR REPLACE PROCEDURE ACTUALIZAR_EXAMEN (
    P_ID_EXAMEN                     IN EXAMENES.ID_EXAMEN%TYPE,
    P_NOMBRE                        IN EXAMENES.NOMBRE%TYPE,
    P_DESCRIPCION                   IN EXAMENES.DESCRIPCION%TYPE,
    P_CODIGO                        IN EXAMENES.CODIGO%TYPE,
    P_TIEMPO                        IN EXAMENES.TIEMPO%TYPE,
    P_CANTIDAD_PREGUNTAS_ALUMNOS    IN EXAMENES.CANTIDAD_PREGUNTAS_ALUMNOS%TYPE,
    P_CANTIDAD_PREGUNTAS_BANCO      IN EXAMENES.CANTIDAD_PREGUNTAS_BANCO%TYPE,
    P_FECHA                         IN EXAMENES.FECHA%TYPE,
    P_PORCENTAJE_NOTA_FINAL         IN EXAMENES.PORCENTAJE_NOTA_FINAL%TYPE,
    P_UMBRAL_APROBACION             IN EXAMENES.UMBRAL_APROBACION%TYPE,
    P_ID_TEMA                       IN EXAMENES.ID_TEMA%TYPE,
    P_ID_PROFESOR                   IN EXAMENES.ID_PROFESOR%TYPE,
    P_ID_UNIDAD                     IN EXAMENES.ID_UNIDAD%TYPE
) IS
    V_CURSOR SYS_REFCURSOR;
    V_EXISTING_EXAMEN EXAMENES%ROWTYPE;
    V_EXISTING_TEMA TEMAS%ROWTYPE;
    V_EXISTING_PROFESOR PROFESORES%ROWTYPE;
    V_EXISTING_UNIDAD UNIDADES%ROWTYPE;
BEGIN
    -- Verificar si el examen existe por ID
    OBTENER_EXAMEN_POR_ID(P_ID_EXAMEN, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_EXAMEN;
    CLOSE V_CURSOR;

    IF V_EXISTING_EXAMEN.ID_EXAMEN IS NULL THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún examen con el ID especificado.');
    END IF;

    -- Verificar si el tema existe
    OBTENER_TEMA_POR_ID(P_ID_TEMA, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_TEMA;
    CLOSE V_CURSOR;

    IF V_EXISTING_TEMA.ID_TEMA IS NULL THEN
        RAISE_APPLICATION_ERROR(-20009, 'No se encontró ningún tema con el ID especificado.');
    END IF;

    -- Verificar si el profesor existe
    OBTENER_PROFESOR_POR_ID(P_ID_PROFESOR, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_PROFESOR;
    CLOSE V_CURSOR;

    IF V_EXISTING_PROFESOR.ID_PROFESOR IS NULL THEN
        RAISE_APPLICATION_ERROR(-20007, 'No se encontró ningún profesor con el ID especificado.');
    END IF;

    -- Verificar si la unidad existe
    OBTENER_UNIDAD_POR_ID(P_ID_UNIDAD, V_CURSOR);
    FETCH V_CURSOR INTO V_EXISTING_UNIDAD;
    CLOSE V_CURSOR;

    IF V_EXISTING_UNIDAD.ID_UNIDAD IS NULL THEN
        RAISE_APPLICATION_ERROR(-20010, 'No se encontró ninguna unidad con el ID especificado.');
    END IF;

    -- Actualizar la información del examen si pasa las validaciones
    UPDATE EXAMENES
    SET
        NOMBRE = P_NOMBRE,
        DESCRIPCION = P_DESCRIPCION,
        CODIGO = P_CODIGO,
        TIEMPO = P_TIEMPO,
        CANTIDAD_PREGUNTAS_ALUMNOS = P_CANTIDAD_PREGUNTAS_ALUMNOS,
        CANTIDAD_PREGUNTAS_BANCO = P_CANTIDAD_PREGUNTAS_BANCO,
        FECHA = P_FECHA,
        PORCENTAJE_NOTA_FINAL = P_PORCENTAJE_NOTA_FINAL,
        UMBRAL_APROBACION = P_UMBRAL_APROBACION,
        ID_TEMA = P_ID_TEMA,
        ID_PROFESOR = P_ID_PROFESOR,
        ID_UNIDAD = P_ID_UNIDAD
    WHERE ID_EXAMEN = P_ID_EXAMEN;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al actualizar la información del examen.');
END ACTUALIZAR_EXAMEN;


-- ELIMINAR UN EXAMEN
CREATE OR REPLACE PROCEDURE ELIMINAR_EXAMEN (
    P_ID_EXAMEN IN EXAMENES.ID_EXAMEN%TYPE
) IS
BEGIN
    DELETE FROM EXAMENES
    WHERE ID_EXAMEN = P_ID_EXAMEN;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ningún examen con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar el examen.');
END ELIMINAR_EXAMEN;


---------------------- CRUD OPCIONES DE RESPUESTA ----------------------------

-- CREAR OPCION DE RESPUESTA
CREATE OR REPLACE PROCEDURE CREAR_OPCION_RESPUESTA (
    P_ID                     IN OPCIONES_RESPUESTA.ID_OPCION_RESPUESTA%TYPE,
    P_TEXTO_RESPUESTA        IN OPCIONES_RESPUESTA.TEXTO_RESPUESTA%TYPE,
    P_CORRECTA               IN OPCIONES_RESPUESTA.CORRECTA%TYPE,
    P_ID_PREGUNTA            IN OPCIONES_RESPUESTA.ID_PREGUNTA%TYPE
) IS
BEGIN
    INSERT INTO OPCIONES_RESPUESTA (
        ID_OPCION_RESPUESTA, TEXTO_RESPUESTA, CORRECTA, ID_PREGUNTA
    ) VALUES (
        P_ID, P_TEXTO_RESPUESTA, P_CORRECTA, P_ID_PREGUNTA
    );
END CREAR_OPCION_RESPUESTA;


-- LISTAR TODAS LAS OPCIONES DE RESPUESTA
CREATE OR REPLACE PROCEDURE LISTAR_OPCIONES_RESPUESTA (P_CURSOR OUT SYS_REFCURSOR) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT ID_OPCION_RESPUESTA, TEXTO_RESPUESTA, CORRECTA, ID_PREGUNTA FROM OPCIONES_RESPUESTA;
END LISTAR_OPCIONES_RESPUESTA;


-- OBTENER UNA OPCION DE RESPUESTA POR SU ID
CREATE OR REPLACE PROCEDURE OBTENER_OPCION_POR_ID (
    P_ID IN OPCIONES_RESPUESTA.ID_OPCION_RESPUESTA%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
  OPEN P_CURSOR FOR
  SELECT ID_OPCION_RESPUESTA, TEXTO_RESPUESTA, CORRECTA, ID_PREGUNTA 
  FROM OPCIONES_RESPUESTA
  WHERE ID_OPCION_RESPUESTA = P_ID;
EXCEPTION
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al obtener la opción de respuesta por ID.');
END OBTENER_OPCION_POR_ID;


-- ACTUALIZAR LA INFORMACION DE UNA OPCION DE RESPUESTA
CREATE OR REPLACE PROCEDURE ACTUALIZAR_OPCION_RESPUESTA (
    P_ID                     IN OPCIONES_RESPUESTA.ID_OPCION_RESPUESTA%TYPE,
    P_TEXTO_RESPUESTA        IN OPCIONES_RESPUESTA.TEXTO_RESPUESTA%TYPE,
    P_CORRECTA               IN OPCIONES_RESPUESTA.CORRECTA%TYPE,
    P_ID_PREGUNTA            IN OPCIONES_RESPUESTA.ID_PREGUNTA%TYPE
) IS
BEGIN
    UPDATE OPCIONES_RESPUESTA
    SET
        TEXTO_RESPUESTA = P_TEXTO_RESPUESTA,
        CORRECTA = P_CORRECTA,
        ID_PREGUNTA = P_ID_PREGUNTA
    WHERE ID_OPCION_RESPUESTA = P_ID;
END ACTUALIZAR_OPCION_RESPUESTA;


-- ELIMINAR UNA OPCION DE RESPUESTA POR SU ID
CREATE OR REPLACE PROCEDURE ELIMINAR_OPCION_RESPUESTA (
    P_ID IN OPCIONES_RESPUESTA.ID_OPCION_RESPUESTA%TYPE
) AS
BEGIN
    DELETE FROM OPCIONES_RESPUESTA 
    WHERE ID_OPCION_RESPUESTA = P_ID;
    
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'No se encontró ninguna opción de respuesta con el ID especificado.');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20003, 'Ocurrió un error al eliminar la opción de respuesta.');
END ELIMINAR_OPCION_RESPUESTA;


----------------------- OTRAS FUNCIONES ----------------------------------------

-- INICIAR SESION ESTUDIANTE
CREATE OR REPLACE PROCEDURE INICIAR_SESION_ESTUDIANTE (
    P_EMAIL      IN  ESTUDIANTES.EMAIL%TYPE,
    P_CONTRASENA IN  ESTUDIANTES.CONTRASENA%TYPE,
    P_CURSOR     OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT ID_ESTUDIANTE, NOMBRE, APELLIDO, EMAIL, SEMESTRE
    FROM ESTUDIANTES
    WHERE EMAIL = P_EMAIL AND CONTRASENA = P_CONTRASENA;
    
    IF NOT P_CURSOR%FOUND THEN
        RAISE_APPLICATION_ERROR(-20021, 'Correo electrónico o contraseña incorrectos.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20022, 'Ocurrió un error durante el inicio de sesión.');
END INICIAR_SESION_ESTUDIANTE;


-- INICIAR SESION PROFESOR
CREATE OR REPLACE PROCEDURE INICIAR_SESION_PROFESOR (
    P_EMAIL      IN  PROFESORES.EMAIL%TYPE,
    P_CONTRASENA IN  PROFESORES.CONTRASENA%TYPE,
    P_CURSOR     OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT ID_PROFESOR, NOMBRE, APELLIDO, EMAIL, ID_MATERIA
    FROM PROFESORES
    WHERE EMAIL = P_EMAIL AND CONTRASENA = P_CONTRASENA;
    
    IF NOT P_CURSOR%FOUND THEN
        RAISE_APPLICATION_ERROR(-20021, 'Correo electrónico o contraseña incorrectos.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20022, 'Ocurrió un error durante el inicio de sesión.');
END INICIAR_SESION_PROFESOR;


-- OBTENER TODAS LAS PREGUNTAS DE UN BANCO
CREATE OR REPLACE PROCEDURE OBTENER_PREGUNTAS_BANCO (
    P_ID_BANCO IN PREGUNTAS.ID_BANCO%TYPE,
    P_CURSOR   OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT 
        P.ID_PREGUNTA,
        P.TEXTO_PREGUNTA,
        P.PORCENTAJE_GENERAL,
        P.PORCENTAJE_SUBPREGUNTA,
        P.TIEMPO,
        P.ID_PRIVACIDAD,
        PRI.TIPO AS TIPO_PRIVACIDAD,
        P.ID_TIPO_PREGUNTA,
        TP.TIPO AS TIPO_PREGUNTA,
        P.ID_PREGUNTA_GENERAL,
        P.ID_PROFESOR,
        PR.NOMBRE || ' ' || PR.APELLIDO AS NOMBRE_PROFESOR,
        P.ID_BANCO
    FROM PREGUNTAS P
    JOIN PRIVACIDAD PRI ON P.ID_PRIVACIDAD = PRI.ID_PRIVACIDAD
    JOIN TIPO_PREGUNTA TP ON P.ID_TIPO_PREGUNTA = TP.ID_TIPO_PREGUNTA
    JOIN PROFESORES PR ON P.ID_PROFESOR = PR.ID_PROFESOR
    WHERE P.ID_BANCO = P_ID_BANCO;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20031, 'Ocurrió un error al obtener las preguntas asociadas al banco.');
END OBTENER_PREGUNTAS_BANCO;


-- OBTENER TODOS LOS ESTUDIANTES DE UN GRUPO
CREATE OR REPLACE PROCEDURE OBTENER_ESTUDIANTES_GRUPO (
    P_ID_GRUPO IN GRUPOS.ID_GRUPO%TYPE,
    P_CURSOR   OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT 
        E.ID_ESTUDIANTE,
        E.NOMBRE,
        E.APELLIDO,
        E.EMAIL,
        --E.CONTRASENA,
        E.SEMESTRE
    FROM ESTUDIANTES E
    JOIN GRUPO_ESTUDIANTE GE ON E.ID_ESTUDIANTE = GE.ID_ESTUDIANTE
    JOIN GRUPOS G ON GE.ID_GRUPO = G.ID_GRUPO
    WHERE G.ID_GRUPO = P_ID_GRUPO;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20031, 'Ocurrió un error al obtener los estudiantes asociados al grupo.');
END OBTENER_ESTUDIANTES_GRUPO;


-- OBTENER TODOS LOS GRUPOS DE UN PROFESOR
CREATE OR REPLACE PROCEDURE OBTENER_GRUPOS_PROFESOR (
    P_ID_PROFESOR IN GRUPOS.ID_PROFESOR%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT 
        G.ID_GRUPO,
        G.NOMBRE AS NOMBRE_GRUPO,
        G.SALON_CLASE,
        G.ID_PROFESOR
    FROM GRUPOS G
    JOIN PROFESORES P ON G.ID_PROFESOR = P.ID_PROFESOR
    WHERE G.ID_PROFESOR = P_ID_PROFESOR;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20031, 'Ocurrió un error al obtener los grupos asociados al profesor.');
END OBTENER_GRUPOS_PROFESOR;


-- OBTENER TODAS LAS UNIDADES CREADAS EN UN GRUPO
CREATE OR REPLACE PROCEDURE OBTENER_UNIDADES_GRUPO (
    P_ID_GRUPO IN GRUPOS.ID_GRUPO%TYPE,
    P_CURSOR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN P_CURSOR FOR
    SELECT 
        U.ID_UNIDAD,
        U.NOMBRE
    FROM UNIDADES U
    JOIN UNIDAD_GRUPO UG ON U.ID_UNIDAD = UG.ID_UNIDAD
    JOIN GRUPOS G ON UG.ID_GRUPO = G.ID_GRUPO
    WHERE G.ID_GRUPO = P_ID_GRUPO;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Ocurrió un error al obtener las unidades asociadas al grupo.');
END OBTENER_UNIDADES_GRUPO;
